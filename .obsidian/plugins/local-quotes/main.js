/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LocalQuotes
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/consts.ts
var author_regexp = /^:::(?:[^:|\s]| )+:::$/m;
var quote_regexp = /^\d+\..+$|^- .+$/m;
var quote_long_regexp = /^\t.+$/m;
var search_regexp = /^(?:[^:|\s]| | \|\| )+$/m;
var code_block_id_regexp = /^id [\w\-_]+$/m;
var code_block_search_regexp = /^search (?:[^:|\s]| | \|\| )+$/m;
var code_block_refreshInterval_regexp = /^refresh \d+[smhdwMy]$/m;
var code_block_customClass_regexp = /^customClass [\w\-_ ]+$/m;
var sec_in_minute = 60;
var sec_in_hour = 3600;
var sec_in_day = 86400;
var sec_in_week = 604800;
var sec_in_month = 2629746;
var sec_in_year = 31556952;

// src/utils/scan.ts
function getAuthorIdx(quoteVault, author) {
  return quoteVault.findIndex((e) => e.author === author);
}
function getBlockMetadataIdx(plugin, id) {
  return plugin.settings.blockMetadata.findIndex((e) => e.id === id);
}
function isTagPresented(app, f, tag, displayWarnings = true) {
  try {
    const fileCache = app.metadataCache.getFileCache(f);
    const tagInContent = fileCache && fileCache.tags && fileCache.tags.findIndex((t) => t.tag === `#${tag}`) >= 0;
    if (tagInContent)
      return true;
    const tagInFrontmatter = fileCache && fileCache.frontmatter && fileCache.frontmatter.tags && fileCache.frontmatter.tags.includes(tag);
    if (tagInFrontmatter)
      return true;
  } catch (e) {
    if (e instanceof TypeError) {
      if (displayWarnings)
        console.log(
          "! This file may have invalid YAML: " + (f == null ? void 0 : f.name) + " (" + (f == null ? void 0 : f.path) + ").\nYou can disable warnings in the settings of the Local Quotes plugin."
        );
      return false;
    } else
      throw e;
  }
}
function findTaggedFiles(app, tag, displayWarnings = true) {
  return app.vault.getMarkdownFiles().filter((file) => isTagPresented(app, file, tag, displayWarnings));
}

// src/utils/quoteVault.ts
function getAuthorsCode(quoteVault, author) {
  return quoteVault[getAuthorIdx(quoteVault, author)].authorCode;
}
function fetchAuthorsInQuoteVault(quoteVault) {
  return quoteVault.map((obj) => obj.author);
}
function fetchAllAuthorsQuotes(quoteVault, author) {
  const quotes = [];
  const authorIdx = getAuthorIdx(quoteVault, author);
  for (const entry of quoteVault[authorIdx].files) {
    quotes.push(...entry.quotes);
  }
  return quotes;
}

// src/utils/random.ts
function getRandomQuoteId(length = 5) {
  const characters = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM1234567890-_";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += getRandomCharOfString(characters);
  }
  return result;
}
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}
function getRandomArrayItem(arr) {
  return arr[getRandomInt(arr.length)];
}
function getRandomCharOfString(str) {
  return str[getRandomInt(str.length)];
}
function getRandomAuthor(quoteVault) {
  return getRandomArrayItem(quoteVault).author;
}
function getWeightedRandomAuthor(quoteVault, customAuthorList = null) {
  let authorToQuoteList;
  if (customAuthorList !== null) {
    authorToQuoteList = customAuthorList.map((e) => {
      let quoteQuantity = 0;
      const author = quoteVault.find((q) => q.author == e);
      author.files.forEach((f) => quoteQuantity += f.quotes.length);
      return [e, quoteQuantity];
    });
  } else {
    authorToQuoteList = quoteVault.map((e) => {
      let quoteQuantity = 0;
      e.files.forEach((f) => quoteQuantity += f.quotes.length);
      return [e.author, quoteQuantity];
    });
  }
  let quotesSum = 0;
  authorToQuoteList.forEach((e) => quotesSum += e[1]);
  const weightedAuthorList = authorToQuoteList.map((e) => [
    e[0],
    e[1] / quotesSum
  ]);
  return getWeightedRandomElement(weightedAuthorList);
}
function getWeightedRandomElement(arr) {
  let i, sum = 0;
  const r = Math.random();
  for (i in arr) {
    sum += arr[i][1];
    if (r <= sum)
      return arr[i][0];
  }
}
function getRandomQuoteOfAuthor(quoteVault, author) {
  const authorIdx = getAuthorIdx(quoteVault, author);
  if (authorIdx < 0) {
    return "You've tried to find an author that doesn't exist";
  } else {
    const quotes = fetchAllAuthorsQuotes(quoteVault, author);
    return quotes[getRandomInt(quotes.length)];
  }
}

// src/libs/remove_markdown.ts
var DEFAULT_OPTIONS = {
  listUnicodeChar: false,
  stripListLeaders: true,
  gfm: true,
  useImgAltText: true,
  abbr: false,
  replaceLinksWithURL: false,
  htmlTagsToSkip: new Array()
};
function removeMd(md, options = null) {
  options = options || DEFAULT_OPTIONS;
  let output = md || "";
  try {
    output = output.replace(/<[^>]*>/g, "").replace(/\[\^.+?\\](\\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\\]: .*?$/g, "").replace(
      /\[([^\]]*?)][[(].*?[\])]/g,
      options.replaceLinksWithURL ? "$2" : "$1"
    ).replace(/^\s{0,3}>\s?/gm, "").replace(/^\s{1,2}\[(.*?)]: (\S+)( ".*?")?\s*$/g, "").replace(/([*]+)(\S)(.*?\S)??\1/g, "$2$3").replace(/(^|\W)(_+)(\S)(.*?\S)??\2($|\W)/g, "$1$3$4$5").replace(/`(.+?)`/g, "$1").replace(/~(.*?)~/g, "$1");
  } catch (e) {
    console.error(e);
    return md;
  }
  return output;
}

// src/utils/file.ts
async function onFileModify(plugin, file) {
  if (isTagPresented(
    plugin.app,
    file,
    plugin.settings.quoteTag,
    plugin.settings.displayWarnings
  )) {
    clearFileEntries(plugin.settings.quoteVault, file.name);
    await updateQuotesVault(plugin, [file]);
  }
}
function clearFileEntries(quoteVault, filename) {
  for (const [eIdx, _] of quoteVault.entries()) {
    quoteVault[eIdx].files = quoteVault[eIdx].files.filter(
      (f) => f.filename !== filename
    );
  }
}
function isFileHaveAuthorsQuote(quoteVault, filename, author, quote) {
  for (const entry of quoteVault[getAuthorIdx(quoteVault, author)].files) {
    if (entry.filename == filename && entry.quotes.includes(quote)) {
      return true;
    }
  }
  return false;
}
function getFilesQuotesIdx(quoteVault, filename, author) {
  return quoteVault[getAuthorIdx(quoteVault, author)].files.findIndex(
    (e) => e.filename == filename
  );
}

// src/types/quote.ts
function getValidAuthorsFromAdvancedSearch(quoteVault, search) {
  const list = search.split("||").map((a) => {
    a = a.trim();
    if (a.length > 0 && getAuthorIdx(quoteVault, a) >= 0)
      return a;
  });
  return list[0] !== void 0 ? list : [];
}
function searchQuote(quoteVault, search, useWeightedRandom) {
  const result = { author: null, text: null };
  if (search === "*") {
    result.author = useWeightedRandom ? getWeightedRandomAuthor(quoteVault) : getRandomAuthor(quoteVault);
  } else if (search_regexp.test(search)) {
    const authorList = getValidAuthorsFromAdvancedSearch(quoteVault, search);
    result.author = useWeightedRandom ? getWeightedRandomAuthor(quoteVault, authorList) : getRandomArrayItem(authorList);
  }
  result.text = getRandomQuoteOfAuthor(quoteVault, result.author);
  return result;
}
async function uploadQuote(quoteVault, filename, authorCode, quote) {
  const author = removeMd(authorCode);
  quote = quote.trim();
  const idx = getAuthorIdx(quoteVault, author);
  if (idx >= 0) {
    if (!isFileHaveAuthorsQuote(quoteVault, filename, author, quote)) {
      const filesQuotesIdx = getFilesQuotesIdx(quoteVault, filename, author);
      quoteVault[idx].files[filesQuotesIdx] = {
        filename,
        quotes: [...quoteVault[idx].files[filesQuotesIdx].quotes, quote]
      };
    }
  } else {
    const tmpFilesQuotes = {
      filename,
      quotes: [quote]
    };
    quoteVault.push({
      author,
      authorCode,
      files: [tmpFilesQuotes]
    });
  }
}
function appendToLastQuote(quoteVault, filename, author, text) {
  const authorIdx = getAuthorIdx(quoteVault, author);
  const filesQuotesIdx = getFilesQuotesIdx(
    quoteVault,
    filename,
    author
  );
  const quoteIdx = quoteVault[authorIdx].files[filesQuotesIdx].quotes.length - 1;
  quoteVault[authorIdx].files[filesQuotesIdx].quotes[quoteIdx] = quoteVault[authorIdx].files[filesQuotesIdx].quotes[quoteIdx] + "\n" + text;
}
async function updateQuotesVault(plugin, files) {
  const tmpQuoteVault = [];
  for (const file of files) {
    let current_author = "";
    for (const line of (await plugin.app.vault.cachedRead(file)).split("\n")) {
      const tline = line.trim();
      if (current_author && quote_regexp.test(tline) && tline.length >= plugin.settings.minimalQuoteLength) {
        await uploadQuote(
          tmpQuoteVault,
          file.name,
          current_author,
          tline.slice(line.indexOf(" "))
        );
      } else if (current_author && quote_long_regexp.test(line) && tline.length >= plugin.settings.minimalQuoteLength) {
        appendToLastQuote(
          tmpQuoteVault,
          file.name,
          removeMd(current_author),
          tline
        );
      } else if (author_regexp.test(tline)) {
        current_author = line.split(":::")[1].trim();
      } else {
        current_author = "";
      }
    }
  }
  plugin.settings.quoteVault = tmpQuoteVault;
  await plugin.saveSettings();
}

// src/utils/parser.ts
function parseOneTimeBlockToCodeBlock(oneTimeBlock) {
  const result = [];
  result.push("```localquote-once");
  result.push(`search ${oneTimeBlock.search}`);
  oneTimeBlock.customClass && result.push(`customClass ${oneTimeBlock.customClass}`);
  result.push("```");
  return result.join("\n");
}
function parseBlockMetadataToCodeBlock(blockMetadata, refreshStr) {
  const result = [];
  result.push("```localquote");
  result.push(`id ${blockMetadata.id}`);
  result.push(`search ${blockMetadata.search}`);
  result.push(`refresh ${refreshStr}`);
  blockMetadata.customClass && result.push(`customClass ${blockMetadata.customClass}`);
  result.push("```");
  return result.join("\n");
}
function parseCodeBlock(content) {
  const result = {
    content: null,
    customClass: null,
    id: null,
    lastUpdate: 0,
    refresh: null,
    search: null
  };
  for (const line of content.split("\n")) {
    if (code_block_id_regexp.test(line))
      result.id = line.split("id ")[1];
    if (code_block_search_regexp.test(line))
      result.search = line.split("search ")[1];
    if (code_block_refreshInterval_regexp.test(line))
      result.refresh = parseTime(line.split("refresh ")[1]);
    if (code_block_customClass_regexp.test(line))
      result.customClass = line.split("customClass ")[1];
  }
  return result;
}
function parseOneTimeCodeBlock(content) {
  const result = {
    filename: null,
    content: null,
    customClass: null,
    search: null
  };
  for (const line of content.split("\n")) {
    if (code_block_search_regexp.test(line))
      result.search = line.split("search ")[1];
    if (code_block_customClass_regexp.test(line))
      result.customClass = line.split("customClass ")[1];
  }
  return result;
}
function parseTime(str) {
  const letter = str.slice(-1);
  const value = parseInt(str);
  if (Number.isNaN(value))
    return null;
  switch (letter) {
    case "s":
      return value;
    case "m":
      return value * sec_in_minute;
    case "h":
      return value * sec_in_hour;
    case "d":
      return value * sec_in_day;
    case "w":
      return value * sec_in_week;
    case "M":
      return value * sec_in_month;
    case "y":
      return value * sec_in_year;
    default:
      return value;
  }
}
function getAllAuthors(quoteVault) {
  return quoteVault.map((e) => e.author);
}

// src/utils/date.ts
function getCurrentSeconds() {
  return Date.now() / 1e3;
}

// src/types/block-metadata.ts
async function makeBlockMetadata(plugin, rawBlockMetadata) {
  rawBlockMetadata.content = searchQuote(
    plugin.settings.quoteVault,
    rawBlockMetadata.search,
    plugin.settings.useWeightedRandom
  );
  rawBlockMetadata.lastUpdate = getCurrentSeconds();
  plugin.settings.blockMetadata.push(rawBlockMetadata);
  await plugin.saveSettings();
  return rawBlockMetadata;
}
async function updateBlockMetadata(plugin, rawBlockMetadata, bmIdx) {
  const prevBm = plugin.settings.blockMetadata[bmIdx];
  if (prevBm.search !== rawBlockMetadata.search) {
    plugin.settings.blockMetadata[bmIdx].search = rawBlockMetadata.search;
    plugin.settings.blockMetadata[bmIdx].content = searchQuote(
      plugin.settings.quoteVault,
      rawBlockMetadata.search,
      plugin.settings.useWeightedRandom
    );
  }
  if (prevBm.customClass !== rawBlockMetadata.customClass) {
    plugin.settings.blockMetadata[bmIdx].customClass = rawBlockMetadata.customClass;
  }
  if (prevBm.refresh !== rawBlockMetadata.refresh) {
    plugin.settings.blockMetadata[bmIdx].refresh = rawBlockMetadata.refresh;
    plugin.settings.blockMetadata[bmIdx].content = searchQuote(
      plugin.settings.quoteVault,
      rawBlockMetadata.search,
      plugin.settings.useWeightedRandom
    );
  }
  const refreshInterval = plugin.settings.blockMetadata[bmIdx].refresh === null ? plugin.settings.defaultReloadInterval : plugin.settings.blockMetadata[bmIdx].refresh;
  if (plugin.settings.blockMetadata[bmIdx].lastUpdate + refreshInterval < getCurrentSeconds()) {
    plugin.settings.blockMetadata[bmIdx].content = searchQuote(
      plugin.settings.quoteVault,
      rawBlockMetadata.search,
      plugin.settings.useWeightedRandom
    );
    plugin.settings.blockMetadata[bmIdx].lastUpdate = getCurrentSeconds();
  }
  await plugin.saveSettings();
  return plugin.settings.blockMetadata[bmIdx];
}
async function selectBlockMetadata(plugin, source) {
  const tmpBm = parseCodeBlock(source);
  const idx = plugin.settings.blockMetadata.findIndex(
    (e) => e.id === tmpBm.id
  );
  if (!(tmpBm.id && tmpBm.search) || plugin.settings.quoteVault.length === 0) {
    return {
      content: {
        author: "Local Quotes",
        text: "You caught an error! Check if quote's author exists. If you can't understand what is wrong you can write an issue on GitHub"
      },
      customClass: null,
      id: null,
      lastUpdate: 0,
      refresh: null,
      search: null
    };
  } else {
    if (idx >= 0)
      return updateBlockMetadata(plugin, tmpBm, idx);
    else
      return makeBlockMetadata(plugin, tmpBm);
  }
}

// src/types/one-time-block.ts
async function makeOneTimeBlock(plugin, rawOneTimeBlock) {
  rawOneTimeBlock.content = searchQuote(
    plugin.settings.quoteVault,
    rawOneTimeBlock.search,
    plugin.settings.useWeightedRandom
  );
  plugin.settings.oneTimeBlocks.push(rawOneTimeBlock);
  await plugin.saveSettings();
  return rawOneTimeBlock;
}
async function updateOneTimeBlock(plugin, rawOneTimeBlock) {
  const otbIdx = plugin.settings.oneTimeBlocks.findIndex(
    (o) => o.filename === rawOneTimeBlock.filename
  );
  const prevOtb = plugin.settings.oneTimeBlocks[otbIdx];
  if (prevOtb.customClass !== rawOneTimeBlock.customClass) {
    plugin.settings.oneTimeBlocks[otbIdx].customClass = rawOneTimeBlock.customClass;
  }
  if (prevOtb.search !== rawOneTimeBlock.search) {
    plugin.settings.oneTimeBlocks[otbIdx].search = rawOneTimeBlock.search;
    plugin.settings.oneTimeBlocks[otbIdx].content = searchQuote(
      plugin.settings.quoteVault,
      rawOneTimeBlock.search,
      plugin.settings.useWeightedRandom
    );
  }
  await plugin.saveSettings();
  return plugin.settings.oneTimeBlocks[otbIdx];
}
async function selectOneTimeBlock(plugin, source, ctx) {
  const tmpOtb = parseOneTimeCodeBlock(source);
  if (!plugin.settings.templateFolder) {
    return {
      content: {
        author: "Local Quotes",
        text: "Your template folder isn't set! Change it in the settings."
      },
      customClass: tmpOtb.customClass,
      filename: null,
      search: null
    };
  } else if (ctx.sourcePath.startsWith(plugin.settings.templateFolder)) {
    return {
      content: {
        author: "Local Quotes",
        text: "Your one time quote will be placed there, when time comes!"
      },
      customClass: tmpOtb.customClass,
      filename: null,
      search: null
    };
  } else {
    const splitSource = ctx.sourcePath.split("/");
    tmpOtb.filename = splitSource[splitSource.length - 1];
    const otbIdx = plugin.settings.oneTimeBlocks.findIndex(
      (o) => o.filename === tmpOtb.filename
    );
    if (otbIdx >= 0)
      return updateOneTimeBlock(plugin, tmpOtb);
    else
      return makeOneTimeBlock(plugin, tmpOtb);
  }
}

// src/processors/code-block.ts
var import_obsidian2 = require("obsidian");

// src/utils/dom.ts
var import_obsidian = require("obsidian");
function createDomLink(doc, text, link) {
  const a = doc.createEl("a");
  a.appendText(text);
  a.href = link;
  return a;
}
async function handlePossibleButtonClick(plugin, ev) {
  const htmlEl = ev.target;
  const caughtButtonClick = htmlEl.matches(".block-language-localquote svg") && ev.type === "click";
  const caughtDoubleClick = htmlEl.matchParent(".block-language-localquote") && ev.type === "dblclick" && plugin.settings.enableDblClick && htmlEl.matchParent(".is-mobile");
  if (caughtButtonClick || caughtDoubleClick) {
    await refreshButtonAction(
      plugin,
      htmlEl.matchParent(".block-language-localquote")
    );
  }
}
async function renderQuoteBlock(app, pluginSettings, el, blockMetadata) {
  if (el.innerHTML != "" || el.innerHTML != null)
    el.innerHTML = "";
  for (const p of pluginSettings.quoteBlockFormat.split("\n")) {
    await import_obsidian.MarkdownRenderer.render(
      app,
      p.replace(
        "{{content}}",
        blockMetadata.content.text.split("\n").join("<br/>")
      ).replace(
        "{{author}}",
        pluginSettings.inheritListingStyle ? getAuthorsCode(
          pluginSettings.quoteVault,
          blockMetadata.content.author
        ) : blockMetadata.content.author
      ),
      el,
      "?no-dataview",
      null
    );
  }
}
async function refreshButtonAction(plugin, el) {
  const mdView = plugin.app.workspace.getActiveViewOfType(import_obsidian.View);
  const blockChild = plugin.settings.usePlainFormat ? "div" : "blockquote";
  const bq = el.find(blockChild);
  const id = bq.getAttr("local-quote-id");
  if (id != null) {
    const bmIdx = getBlockMetadataIdx(plugin, id);
    plugin.settings.blockMetadata[bmIdx].content = searchQuote(
      plugin.settings.quoteVault,
      plugin.settings.blockMetadata[bmIdx].search,
      plugin.settings.useWeightedRandom
    );
    await plugin.saveSettings();
    await rerenderAllQuotesForView(plugin, mdView);
  }
}
async function rerenderAllQuotesForView(plugin, mdView, quotesMap = null) {
  if (quotesMap == null)
    quotesMap = formQuotesMap(plugin.settings, mdView);
  for (const id of quotesMap.keys()) {
    const blockMetadata = plugin.settings.blockMetadata[getBlockMetadataIdx(plugin, id)];
    for (const el of quotesMap.get(id))
      await renderQuoteBlock(plugin.app, plugin.settings, el, blockMetadata);
  }
}
async function _rerenderAllQuotesForView(plugin, mdView, quotesMap = null) {
  if (quotesMap == null)
    quotesMap = formQuotesMap(plugin.settings, mdView);
  for (const id of quotesMap.keys()) {
    const idx = getBlockMetadataIdx(plugin, id);
    const blockMetadata = plugin.settings.blockMetadata[idx];
    const refreshInterval = plugin.settings.blockMetadata[idx].refresh === null ? plugin.settings.defaultReloadInterval : plugin.settings.blockMetadata[idx].refresh;
    if (plugin.settings.blockMetadata[idx].lastUpdate + refreshInterval < getCurrentSeconds()) {
      plugin.settings.blockMetadata[idx].lastUpdate = getCurrentSeconds();
      plugin.settings.blockMetadata[idx].content = searchQuote(
        plugin.settings.quoteVault,
        plugin.settings.blockMetadata[idx].search,
        plugin.settings.useWeightedRandom
      );
      for (const el of quotesMap.get(id))
        await renderQuoteBlock(plugin.app, plugin.settings, el, blockMetadata);
    }
  }
}
async function refreshAllQuotesForView(plugin, mdView) {
  const quotesMap = formQuotesMap(plugin.settings, mdView);
  for (const id of quotesMap.keys()) {
    const bmIdx = getBlockMetadataIdx(plugin, id);
    plugin.settings.blockMetadata[bmIdx].content = searchQuote(
      plugin.settings.quoteVault,
      plugin.settings.blockMetadata[bmIdx].search,
      plugin.settings.useWeightedRandom
    );
  }
  await plugin.saveSettings();
  await rerenderAllQuotesForView(plugin, mdView, quotesMap);
}

// src/processors/code-block.ts
async function processCodeBlock(plugin, source, el) {
  const blockMetadata = await selectBlockMetadata(
    plugin,
    source
  );
  if (!plugin.settings.usePlainFormat)
    el.addClass("el-blockquote");
  if (blockMetadata.customClass !== null)
    el.addClasses(blockMetadata.customClass.split(" "));
  const bq = el.createEl(
    plugin.settings.usePlainFormat ? "div" : "blockquote"
  );
  el.appendChild(bq);
  bq.setAttribute("local-quote-id", blockMetadata.id);
  if (!plugin.settings.hideRefreshButton && !(plugin.settings.enableDblClick && el.matchParent(".is-mobile"))) {
    const iconEl = el.createEl("a", { cls: "reset-icon" });
    (0, import_obsidian2.setIcon)(iconEl, "lucide-rotate-ccw");
  }
  await renderQuoteBlock(plugin.app, plugin.settings, bq, blockMetadata);
}
async function processOneTimeCodeBlock(plugin, source, el, ctx) {
  const oneTimeBlock = await selectOneTimeBlock(
    plugin,
    source,
    ctx
  );
  if (!plugin.settings.usePlainFormat)
    el.addClass("el-blockquote");
  if (oneTimeBlock.customClass !== null)
    el.addClasses(oneTimeBlock.customClass.split(" "));
  const bq = el.createEl(
    plugin.settings.usePlainFormat ? "div" : "blockquote"
  );
  el.appendChild(bq);
  await renderQuoteBlock(plugin.app, plugin.settings, bq, oneTimeBlock);
}
function formQuotesMap(pluginSettings, mdView) {
  const blockChild = pluginSettings.usePlainFormat ? "div" : "blockquote";
  const quotesMap = /* @__PURE__ */ new Map();
  mdView.containerEl.findAll(".block-language-localquote " + blockChild).forEach((e) => {
    const id = e.getAttr("local-quote-id");
    if (quotesMap.has(id))
      quotesMap.set(id, quotesMap.get(id).concat(e));
    else
      quotesMap.set(id, [e]);
  });
  return quotesMap;
}

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  quoteTag: "quotes",
  defaultReloadInterval: sec_in_day,
  minimalQuoteLength: 5,
  autoGeneratedIdLength: 5,
  inheritListingStyle: false,
  updateFilesQuotesOnModify: true,
  quoteBlockFormat: "{{content}}\n\u2014 {{author}}",
  usePlainFormat: false,
  useWeightedRandom: false,
  blockMetadata: [],
  oneTimeBlocks: [],
  quoteVault: [],
  templateFolder: "",
  hideRefreshButton: false,
  displayWarnings: true,
  enableDblClick: true,
  useAutomaticRefreshInterval: true,
  automaticRefreshInterval: 1e3,
  _automaticRefreshIntervalObject: null
};
var LocalQuotesSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "General" });
    new import_obsidian3.Setting(containerEl).setName("Use automatic refresh interval").setDesc(
      "If you turn it on, your quotes will be refreshed automatically without reopening the note. You need to restart Obsidian to make this option work."
    ).addToggle(
      (t) => t.setValue(this.plugin.settings.useAutomaticRefreshInterval).onChange(async (value) => {
        this.plugin.settings.useAutomaticRefreshInterval = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Quote tag").setDesc("Tag name that will be used for searching notes with quotes").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.quoteTag).setValue(this.plugin.settings.quoteTag).onChange(async (value) => {
        this.plugin.settings.quoteTag = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Refresh interval").setDesc(
      "You can set default refresh interval (in seconds) and miss corresponding field in code block (default 86400 seconds equals 1 day)"
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.defaultReloadInterval.toString()).setValue(this.plugin.settings.defaultReloadInterval.toString()).onChange(async (value) => {
        this.plugin.settings.defaultReloadInterval = parseInt(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Template folder").setDesc("Folder that will be ignored by one-time quotes").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.templateFolder).setValue(this.plugin.settings.templateFolder).onChange(async (value) => {
        this.plugin.settings.templateFolder = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Style" });
    new import_obsidian3.Setting(containerEl).setName("Inherit listing's authors' style").setDesc(
      "You can use style in your listings like `:::**Author**:::`, if this setting turns on, your quote blocks will inherit this styling"
    ).addToggle(
      (t) => t.setValue(this.plugin.settings.inheritListingStyle).onChange(async (value) => {
        this.plugin.settings.inheritListingStyle = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Quote block format").setDesc(
      "Set your own format for quote blocks. Use {{content}} and {{author}} placeholders to place data"
    ).addTextArea(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.quoteBlockFormat).setValue(this.plugin.settings.quoteBlockFormat).onChange(async (value) => {
        this.plugin.settings.quoteBlockFormat = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Use plain format").setDesc(
      `If you turn it on, your quotes will be placed in a simple div block without "quote" appearance, it'll be placed as plain text`
    ).addToggle(
      (st) => st.setValue(this.plugin.settings.usePlainFormat).onChange(async (value) => {
        this.plugin.settings.usePlainFormat = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Advanced" });
    new import_obsidian3.Setting(containerEl).setName("Hide refresh button").setDesc("If you turn it on, refresh button will disappear constantly.").addToggle(
      (t) => t.setValue(this.plugin.settings.hideRefreshButton).onChange(async (value) => {
        this.plugin.settings.hideRefreshButton = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Handle double click on mobile").setDesc(
      "If you turn it on, you can refresh quote block just with twice tap on it. Refresh button will disappear (only on mobile)."
    ).addToggle(
      (t) => t.setValue(this.plugin.settings.enableDblClick).onChange(async (value) => {
        this.plugin.settings.enableDblClick = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Use weighted random").setDesc(
      "If you turn it on, plugin will use weighted random strategy so then more quotes author has then more probability of choosing exactly this author."
    ).addToggle(
      (t) => t.setValue(this.plugin.settings.useWeightedRandom).onChange(async (value) => {
        this.plugin.settings.useWeightedRandom = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Automatically update quote listing").setDesc(
      "If you turn it on plugin will scan your file for new quotes when you modify it. Requires app relaunch to apply setting change"
    ).addToggle(
      (t) => t.setValue(this.plugin.settings.updateFilesQuotesOnModify).onChange(async (value) => {
        this.plugin.settings.updateFilesQuotesOnModify = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Minimum quote length").setDesc("Quotes shorter than this length will not be included").addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.minimalQuoteLength.toString()).setValue(this.plugin.settings.minimalQuoteLength.toString()).onChange(async (value) => {
        this.plugin.settings.minimalQuoteLength = parseInt(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Auto generated id length").setDesc(
      "This setting affects on length of id that automatically generates in 'Quote Maker'"
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.autoGeneratedIdLength.toString()).setValue(this.plugin.settings.autoGeneratedIdLength.toString()).onChange(async (value) => {
        this.plugin.settings.autoGeneratedIdLength = parseInt(value);
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Danger Zone" });
    new import_obsidian3.Setting(containerEl).setName("Automatic refresh interval").setDesc(
      "You can set default automatic refresh interval (in miliseconds). You need to restart Obsidian to make this option work."
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.automaticRefreshInterval.toString()).setValue(this.plugin.settings.automaticRefreshInterval.toString()).onChange(async (value) => {
        this.plugin.settings.automaticRefreshInterval = parseInt(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Display warnings").setDesc(
      "If you turn it on plugin will display any warning those need your attention in the developer console. If it's annoying and you don't agree with warnings or will not fix them, you can disable this option."
    ).addToggle(
      (t) => t.setValue(this.plugin.settings.displayWarnings).onChange(async (value) => {
        this.plugin.settings.displayWarnings = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Clear block metadata").setDesc(
      "Set blockMetadata property to empty array (use if you have problems with old quote occurrence)"
    ).addButton(
      (btn) => btn.setButtonText("Clear").onClick(async () => {
        this.plugin.settings.blockMetadata = [];
        await this.plugin.saveSettings();
        new import_obsidian3.Notice("Your block metadata successfully cleared!");
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Clear one-time blocks").setDesc(
      "Set oneTimeBlocks property to empty array (use if you have problems with mismatched template folder)"
    ).addButton(
      (btn) => btn.setButtonText("Clear").onClick(async () => {
        this.plugin.settings.oneTimeBlocks = [];
        await this.plugin.saveSettings();
        new import_obsidian3.Notice("Your one-time blocks successfully cleared!");
      })
    );
  }
};

// src/processors/modals/quote-maker.ts
var import_obsidian4 = require("obsidian");
var QuoteMakerModal = class extends import_obsidian4.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.editor = plugin.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView).editor;
  }
  async onOpen() {
    const authorList = fetchAuthorsInQuoteVault(
      this.plugin.settings.quoteVault
    );
    const randomId = getRandomQuoteId(
      this.plugin.settings.autoGeneratedIdLength
    );
    let tmpRefreshChar = "d";
    let tmpRefreshNum = 1;
    let tmpSearch = authorList[0];
    this.result = {
      content: { author: null, text: null },
      id: randomId,
      search: null,
      refresh: 86400,
      customClass: null,
      lastUpdate: 0
    };
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "\u{1F6E0}\uFE0F Quote Maker" });
    new import_obsidian4.Setting(contentEl).setName("Id").setDesc(
      "A way to identify your quote block, you can leave it or change to your own one"
    ).addText(
      (text) => text.setValue(this.result.id).onChange((value) => {
        if (value.length > 0)
          this.result.id = value;
        else
          this.result.id = randomId;
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Custom class").setDesc("Set custom css class (from snippets, for example)").addText(
      (text) => text.setValue("").onChange((value) => {
        if (value.length > 0)
          this.result.customClass = value;
        else
          this.result.customClass = null;
      })
    );
    contentEl.createEl("h3", { text: "Search" });
    contentEl.createEl("p", {
      text: "(in the quote block will be used a last edited field ('Author' or 'Advanced search'))",
      cls: "local-quotes-heading-desc"
    });
    new import_obsidian4.Setting(contentEl).setName("Author").setDesc(
      "Choose author for your quote block (if you want choose only one)"
    ).addDropdown((dropdown) => {
      authorList.map((author) => dropdown.addOption(author, author));
      dropdown.setValue(tmpSearch);
      dropdown.onChange((value) => {
        tmpSearch = value;
      });
    });
    new import_obsidian4.Setting(contentEl).setName("Advanced search").setDesc(
      createFragment((e) => {
        const p = e.createEl("span");
        p.appendText("You can freely use '*' and || after reading ");
        p.appendChild(
          createDomLink(
            p,
            "search guide",
            "https://github.com/ka1tzyu/local-quotes/wiki/How-to-use-search"
          )
        );
      })
    ).addText(
      (text) => text.setValue(tmpSearch).onChange((value) => {
        tmpSearch = value;
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Search validator").setDesc("Summons notice with validated (existent) authors").addButton(
      (btn) => btn.setButtonText("Check").setCta().onClick(() => {
        let validatedAuthors;
        if (tmpSearch === "*") {
          validatedAuthors = getAllAuthors(this.plugin.settings.quoteVault);
        } else {
          validatedAuthors = getValidAuthorsFromAdvancedSearch(
            this.plugin.settings.quoteVault,
            tmpSearch
          );
        }
        new import_obsidian4.Notice(
          validatedAuthors.length > 0 ? "Validated authors:\n" + validatedAuthors.join("\n") : "Plugin can't find authors those you mentioned!\nTry to change search."
        );
      })
    );
    contentEl.createEl("h3", { text: "Refresh settings" });
    new import_obsidian4.Setting(contentEl).setName("Refresh interval value").setDesc("Set the value of your interval (only number!)").addText(
      (text) => text.setValue(tmpRefreshNum.toString()).onChange((value) => {
        tmpRefreshNum = parseInt(value);
        this.result.refresh = parseTime(tmpRefreshNum + tmpRefreshChar);
      })
    );
    new import_obsidian4.Setting(contentEl).setName("Refresh interval modifier").setDesc("Choose the modifier for value clarification").addDropdown(
      (dropdown) => dropdown.addOption("s", "second").addOption("m", "minute").addOption("h", "hour").addOption("d", "day").addOption("w", "week").addOption("M", "month").addOption("y", "year").setValue(tmpRefreshChar).onChange((value) => {
        tmpRefreshChar = value;
        this.result.refresh = parseTime(tmpRefreshNum + tmpRefreshChar);
      })
    );
    const buttonContainer = contentEl.createEl("div");
    buttonContainer.addClass("local-quotes-modal-button-container");
    new import_obsidian4.Setting(buttonContainer).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.onClose();
        this.close();
      })
    );
    new import_obsidian4.Setting(buttonContainer).addButton(
      (btn) => btn.setButtonText("Insert Quote").setCta().onClick(() => {
        this.result.search = tmpSearch;
        this.editor.replaceRange(
          parseBlockMetadataToCodeBlock(
            this.result,
            tmpRefreshNum + tmpRefreshChar
          ),
          this.editor.getCursor()
        );
        this.onClose();
        this.close();
        new import_obsidian4.Notice(
          `Quote '${this.result.id}' via '${this.result.search}' inserted!`
        );
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/processors/modals/quote-vault-error.ts
var import_obsidian6 = require("obsidian");

// src/processors/modals/functions.ts
var import_obsidian5 = require("obsidian");
function okCloserButton(modal) {
  const buttonContainer = modal.contentEl.createEl("div");
  buttonContainer.addClass("local-quotes-modal-button-container");
  new import_obsidian5.Setting(buttonContainer).addButton(
    (btn) => btn.setButtonText("OK").setCta().onClick(() => {
      modal.onClose();
      modal.close();
    })
  );
}
function getQuotesCount(quote) {
  let cnt = 0;
  for (const file of quote.files) {
    cnt += file.quotes.length;
  }
  return cnt;
}
function sortQuoteVaultEntries(a, b) {
  if (getQuotesCount(a) < getQuotesCount(b))
    return -1;
  if (getQuotesCount(a) > getQuotesCount(b))
    return 1;
  return 0;
}

// src/processors/modals/quote-vault-error.ts
var QuoteVaultErrorModal = class extends import_obsidian6.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h3", { text: "\u274C Local Quote Error" });
    contentEl.createEl("p", {
      text: "After scan there is no any quote listings in your vault."
    });
    const a = createDomLink(
      contentEl,
      "wiki page",
      "https://github.com/ka1tzyu/local-quotes/wiki/How-quote-listings-work"
    );
    const p = contentEl.createEl("p");
    p.appendText(
      "If you want to learn more about quote listings and understand how it works you can visit "
    );
    p.appendChild(a);
    p.appendText(".");
    okCloserButton(this);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/processors/modals/one-time-quote-maker.ts
var import_obsidian7 = require("obsidian");
var OneTimeQuoteMakerModal = class extends import_obsidian7.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.editor = plugin.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView).editor;
  }
  async onOpen() {
    const authorList = fetchAuthorsInQuoteVault(
      this.plugin.settings.quoteVault
    );
    let tmpSearch = authorList[0];
    this.result = {
      customClass: null,
      filename: null,
      search: null,
      content: {
        author: null,
        text: null
      }
    };
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "\u{1F5D3} One-Time Quote Maker" });
    new import_obsidian7.Setting(contentEl).setName("Custom class").setDesc("Set custom css class (from snippets, for example)").addText(
      (text) => text.setValue("").onChange((value) => {
        if (value.length > 0)
          this.result.customClass = value;
        else
          this.result.customClass = null;
      })
    );
    contentEl.createEl("h3", { text: "Search" });
    contentEl.createEl("p", {
      text: "(in the quote block will be used a last edited field ('Author' or 'Advanced search'))",
      cls: "local-quotes-heading-desc"
    });
    new import_obsidian7.Setting(contentEl).setName("Author").setDesc(
      "Choose author for your quote block (if you want choose only one)"
    ).addDropdown((dropdown) => {
      authorList.map((author) => dropdown.addOption(author, author));
      dropdown.setValue(tmpSearch);
      dropdown.onChange((value) => {
        tmpSearch = value;
      });
    });
    new import_obsidian7.Setting(contentEl).setName("Advanced search").setDesc(
      createFragment((e) => {
        const p = e.createEl("span");
        p.appendText("You can freely use '*' and || after reading ");
        p.appendChild(
          createDomLink(
            p,
            "search guide",
            "https://github.com/ka1tzyu/local-quotes/wiki/How-to-use-search"
          )
        );
      })
    ).addText(
      (text) => text.setValue(tmpSearch).onChange((value) => {
        tmpSearch = value;
      })
    );
    new import_obsidian7.Setting(contentEl).setName("Search validator").setDesc("Summons notice with validated (existent) authors").addButton(
      (btn) => btn.setButtonText("Check").setCta().onClick(() => {
        let validatedAuthors;
        if (tmpSearch === "*") {
          validatedAuthors = getAllAuthors(this.plugin.settings.quoteVault);
        } else {
          validatedAuthors = getValidAuthorsFromAdvancedSearch(
            this.plugin.settings.quoteVault,
            tmpSearch
          );
        }
        new import_obsidian7.Notice(
          validatedAuthors.length > 0 ? "Validated authors:\n" + validatedAuthors.join("\n") : "Plugin can't find authors those you mentioned!\nTry to change search."
        );
      })
    );
    const buttonContainer = contentEl.createEl("div");
    buttonContainer.addClass("local-quotes-modal-button-container");
    new import_obsidian7.Setting(buttonContainer).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.onClose();
        this.close();
      })
    );
    new import_obsidian7.Setting(buttonContainer).addButton(
      (btn) => btn.setButtonText("Insert Quote").setCta().onClick(() => {
        this.result.search = tmpSearch;
        this.editor.replaceRange(
          parseOneTimeBlockToCodeBlock(this.result),
          this.editor.getCursor()
        );
        this.onClose();
        this.close();
        new import_obsidian7.Notice(`One-time quote inserted!`);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/processors/modals/statistics.ts
var import_obsidian8 = require("obsidian");
var StatisticsModal = class extends import_obsidian8.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "\u{1F4C9} Local Quote Statictics" });
    contentEl.createEl("p", {
      text: "Just research and refrect. All data fresh and clear, baked just a moment ago."
    });
    contentEl.createEl("h3", {
      text: "Block data"
    });
    contentEl.createEl("p", {
      text: `Quantity of the block metadatas: ${this.plugin.settings.blockMetadata.length}`,
      cls: "local-quotes-statistics-p"
    });
    contentEl.createEl("p", {
      text: `Quantity of the one-time blocks: ${this.plugin.settings.oneTimeBlocks.length}`,
      cls: "local-quotes-statistics-p"
    });
    contentEl.createEl("h3", {
      text: "Quote listings"
    });
    this.plugin.settings.quoteVault.sort(sortQuoteVaultEntries).reverse().forEach((q, i) => {
      contentEl.createEl("p", {
        text: `${i + 1}. ${q.author}: ${getQuotesCount(q)}`,
        cls: "local-quotes-statistics-p"
      });
    });
    okCloserButton(this);
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/main.ts
var LocalQuotes = class extends import_obsidian9.Plugin {
  async onload() {
    console.log("loading Local Quotes...");
    await this.loadSettings();
    this.app.workspace.onLayoutReady(async () => {
      await updateQuotesVault(
        this,
        findTaggedFiles(
          this.app,
          this.settings.quoteTag,
          this.settings.displayWarnings
        )
      );
      if (this.settings.useAutomaticRefreshInterval) {
        this.settings._automaticRefreshIntervalObject = window.setInterval(
          () => {
            const formed = formQuotesMap(
              this.settings,
              this.app.workspace.getActiveViewOfType(import_obsidian9.View)
            );
            if (formed.size > 0) {
              _rerenderAllQuotesForView(
                this,
                this.app.workspace.getActiveViewOfType(import_obsidian9.View),
                formed
              );
            }
          },
          this.settings.automaticRefreshInterval
        );
        this.registerInterval(this.settings._automaticRefreshIntervalObject);
      }
    });
    if (this.settings.updateFilesQuotesOnModify) {
      this.registerEvent(
        this.app.metadataCache.on("changed", (f) => onFileModify(this, f))
      );
    }
    this.registerMarkdownCodeBlockProcessor(
      "localquote",
      (src, el, _) => processCodeBlock(this, src, el)
    );
    this.registerMarkdownCodeBlockProcessor(
      "localquote-once",
      (src, el, ctx) => processOneTimeCodeBlock(this, src, el, ctx)
    );
    this.addSettingTab(new LocalQuotesSettingTab(this));
    this.registerDomEvent(
      document,
      "click",
      (ev) => handlePossibleButtonClick(this, ev)
    );
    this.registerDomEvent(
      document,
      "dblclick",
      (ev) => handlePossibleButtonClick(this, ev)
    );
    this.addCommand({
      id: "rescan-local-quotes",
      name: "Rescan vault for local quotes",
      callback: async () => {
        await updateQuotesVault(
          this,
          findTaggedFiles(
            this.app,
            this.settings.quoteTag,
            this.settings.displayWarnings
          )
        );
        new import_obsidian9.Notice("Your quote listings successfully updated!");
      }
    });
    this.addCommand({
      id: "open-local-quotes-block-maker",
      name: "Open Quote Maker",
      callback: async () => {
        await updateQuotesVault(
          this,
          findTaggedFiles(
            this.app,
            this.settings.quoteTag,
            this.settings.displayWarnings
          )
        );
        if (this.settings.quoteVault && this.settings.quoteVault.length > 0) {
          new QuoteMakerModal(this).open();
        } else {
          new QuoteVaultErrorModal(this.app).open();
        }
      }
    });
    this.addCommand({
      id: "open-local-quotes-one-time-block-maker",
      name: "Open One-Time Quote Maker",
      callback: async () => {
        await updateQuotesVault(
          this,
          findTaggedFiles(
            this.app,
            this.settings.quoteTag,
            this.settings.displayWarnings
          )
        );
        if (this.settings.quoteVault && this.settings.quoteVault.length > 0) {
          new OneTimeQuoteMakerModal(this).open();
        } else {
          new QuoteVaultErrorModal(this.app).open();
        }
      }
    });
    this.addCommand({
      id: "local-quotes-refresh-active-file",
      name: "Refresh local quotes for active file",
      callback: () => {
        refreshAllQuotesForView(
          this,
          this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView)
        );
      }
    });
    this.addCommand({
      id: "open-local-quotes-statistics",
      name: "Open Statistics",
      callback: async () => {
        await updateQuotesVault(
          this,
          findTaggedFiles(
            this.app,
            this.settings.quoteTag,
            this.settings.displayWarnings
          )
        );
        if (this.settings.quoteVault && this.settings.quoteVault.length > 0) {
          new StatisticsModal(this).open();
        } else {
          new QuoteVaultErrorModal(this.app).open();
        }
      }
    });
  }
  async onunload() {
    clearInterval(this.settings._automaticRefreshIntervalObject);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
